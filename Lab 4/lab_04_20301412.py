# -*- coding: utf-8 -*-
"""lab_04_20301412.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r263IcESmcIhXP-ARDd0E-kod0suHT5v
"""

def parse_input_string(input_string, parse_table):
    counter = []          #store the parsing progress at each step
    matched_array = []    #store the tokens that have been successfully matched during parsing.
    input_stack = ['$', 'E']
    input_token = input_string.split() + ['$']
    counter.append((matched_array.copy(), input_stack.copy(), ' '.join(input_token), " ", ""))  # current state of the parsing process

    while input_stack:

        current_input = input_token[0]
        top_input_stack = input_stack[-1]

        if top_input_stack in parse_table:
            if current_input in parse_table[top_input_stack]:
                action = parse_table[top_input_stack][current_input]
                action_rule = top_input_stack + "--> " + action
                b= "output"
                if action == 'ϵ':
                    input_stack.pop()
                else:
                    input_stack.pop()
                    for symbol in reversed(action.split()):
                        if symbol != 'ϵ':
                            input_stack.append(symbol)
                counter.append((matched_array.copy(), input_stack.copy(), ' '.join(input_token), action_rule,b))
            else:
                raise ValueError(f"Parse table has no entry for '{top_input_stack}' and input '{current_input}'.")

        elif top_input_stack == "$":
          break
        elif top_input_stack == current_input:
            action_rule = current_input
            a= input_stack.pop()   # temporarily store the symbol that is being popped from the input stack.
            input_token = input_token[1:]
            b="match"
            counter.append((matched_array.copy(), input_stack.copy(), ' '.join(input_token), action_rule,b))
            matched_array.append(a)

        else:
            raise ValueError(f" '{current_input}' does not match with the top of the input_stack '{top_input_stack}'.")


    return counter

parse_table = {
    'E': {'id': "T E'", '(': "T E'"},
    "E'": {'+': "+ T E'", '$': 'ϵ'},
    'T': {'id': "F T'", '(': "F T'"},
    "T'": {'*': "* F T'", '+': 'ϵ', ')': 'ϵ', '$': 'ϵ'},
    'F': {'id': "id", '(': "( E )"}
}

input_string = "id + id * id"

parsing_counter = parse_input_string(input_string, parse_table)


print("{:<18} {:<18} {:<22} {:<18}".format("Matched", "Stack", "Input", "Action"))
print("\n")
for matched_array, input_stack, input_str, action,b in parsing_counter:
    input_stack.reverse()
    matched_array_str = ' '.join(matched_array)
    input_stack_str = ''.join(input_stack)
    input_str = input_str if input_str else "$"

    print("{:<18} {:<18} {:<22} {} {:<18}".format(matched_array_str, input_stack_str, input_str, b, action))